---
date: 2024-12-29
tags:
  - log
  - glide
---
Hellooooo! We're back, and today I want to reorganize and refactor some of the methods, especially on the server side. All the changes we made in the [[6. Ready to Glide!|last log]] was a bit messy 😬. So let's dive in!
## Refactoring
Right now, all our function are scattered around, some in `struct Command`, and others like `handle_command`, `cmd_list`, `cmd_reqs` etc. are just floating around. We could refactor all this into `struct Commands`, [like so](https://github.com/ngpal/glide/commit/f888e60f2b7a86b9cbb797e84f0732b93d5c397c). This looks a whole lot cleaner doesn't it? I'm still conflicted on keeping the `Command` enum itself, because if we're going to `execute` and consume the enum variant as soon as we `parse` the command, where do we need to use this enum? But I have a feeling it might come useful in the future maybe. Let's keep it for now.

After some more [trivial changes](https://github.com/ngpal/glide/commit/66eb502b4d66463cdecea9b17b41f0f75d9ad4e0), like adding command line arguments support for the client, and opening up the connection to the local network in the server, we're ready to move on!
## Actual file transferring!
Finally! We're at the big finale, getting file transferring working. Here's how our program flow is going to look like,
- `clientA` and `clientB` connect to the server
- `clientA` sends a request to `clientB`, blocking `clientA` (on the client side) from performing other actions, until `clientB` responds.
	- `clientB` responds with an `OK` signal, and the file is send chunk by chunk from  `clientA` to `clientB`
	- OR `clientB` responds with a `NO` signal, and the request is removed, `clientA` is informed, everything is done.

Sounds good? Great, let's get to it!
### Detour: Major Blunder
Remember our implementation of the `glide` command?
```rust
    async fn cmd_glide(&self, state: &SharedState, username: &str) -> String {
        let (path, to) = match self {
            Command::Glide { path, to } => (path, to),
            _ => unreachable!(),
        };

        // Check if file exists
        if !Path::new(path).exists() && fs::metadata(&path).unwrap().is_file() {
            return format!("Path '{}' is invalid. File does not exist", path);
        }

        // Check if user exists
        let mut clients = state.lock().await;
        if !clients.contains_key(to) && username != to {
            return format!("User @{} does not exist", to);
        }

        let file_size = fs::metadata(&path).unwrap().size();

        // Add request
        clients
            .get_mut(to)
            .unwrap()
            .incoming_requests
            .push(Request {
                from_username: username.to_string(),
                filename: path.to_string(),
                size: file_size,
            });

        format!("Successfully sent share request to @{} for {}", to, path)
    }
```

Spot the problem? Why are we checking if the file exists in the server!? Shouldn't we be doing those checks in the client before sending the damn command over?? 🤦🏾‍♂️ I knew things were going too smoothly. Let's get on top of this horrible mishap. And this would be the perfect chance to move the commands into a separate crate called `utils`, because then we can parse the command at the client itself and check the validity of the commands. 

```rust title="client.rs 13"
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
	// -- snip --

    // Command loop
    let stdin = io::stdin();
    let mut input = String::new();

    println!("Type 'help' to see available commands.");

    loop {
        // Get user input
        input.clear();
        print!("glide> ");
        io::stdout().flush()?;
        stdin.lock().read_line(&mut input)?;

        let input = input.trim();
        if input == "exit" {
            println!("Thank you for using Glide. Goodbye!");
            break;
        }

        // Parse the command
        let command = Command::parse(input);

        // Validate glide command
        if let Command::Glide { path, to } = command {
            // Check if file exists
            if Path::new(&path).try_exists().is_err() || !Path::new(&path).is_file() {
                println!("Path '{}' is invalid. File does not exist", path);
                continue;
            }

        }

        // Send command to the server
        stream.write_all(command.as_bytes()).await?;

        // Await server response
        let mut response = vec![0; CHUNK_SIZE];
        let bytes_read = stream.read(&mut response).await?;
        if bytes_read == 0 {
            println!("Server disconnected.");
            break;
        }

        // Print server response
        let response_str = String::from_utf8_lossy(&response[..bytes_read]);
        println!("{}", response_str);
    }

}
```

And everything seems to be working as expected. Now a lot of my previous oversights are showing up. First of all, I find it pretty annoying that the server is sending whole messages instead of codes or tiny messages like `OK` or just a list of usernames instead of whole formatted text to be outputted by the client. This will hinder our process when we're trying to develop and alternative client. So let's do a clean sweep of all those nasty messages, package them into enums, and use these enums to send and receive these messages. First let's classify the types of messages the server sends.
- Invalid username
- Username taken
- Username accepted
- Unknown command
- Unknown user
- Connected users list
- Incoming requests list
- Share request successful 
- and the help command, which I don't know why its not purely a client side implementation but here we are. 
These are all the things the server sends to the user as plain text, as of now. Let's get some enums going! 

After adding the enums (code changes were too big to show here, check out the repo [here](https://github.com/ngpal/glide/commit/dc1690cb20dc858f89ab42a282fa0b68873171ae)), let's integrate these enums into the code. 