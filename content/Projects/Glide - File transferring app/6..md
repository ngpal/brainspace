---
date: 2024-12-26
draft: []
tags:
  - glide
  - log
---
Hey there! Last time, we stopped after implementing the `list` command, which prints a list of all the users connected to the server. As a part of that, we also did a lot of bug squashing. Today we're gonna tackle the rest of the commands mentioned in [[5. Major Overhauls and Commands#Commands|last log]], starting with `glide` to send a share request to someone. But before that we should probably do some
## Structuring üë∑üèæ‚Äç‚ôÇÔ∏è!
Let's start by making enum variants, and a method to parse a command into one of those enum variants. This can help us evaluate the commands.
```rust title="glide-server/src/main.rs 10:0"
enum Command {
    List,
    Requests,
    Glide { path: String, to: String },
    Ok(String),
    No(String),
    Help(Option<String>),
    InvalidCommand(String),
}

impl Command {
    fn parse(input: &str) -> Command {
        let glide_re = Regex::new(r"^glide\s+(.+)\s+@(.+)$").unwrap();
        let ok_re = Regex::new(r"^ok\s+@(.+)$").unwrap();
        let no_re = Regex::new(r"^no\s+@(.+)$").unwrap();
        let help_re = Regex::new(r"^help(?:\s+(.+))?$").unwrap();

        if input == "list" {
            Command::List
        } else if input == "reqs" {
            Command::Requests
        } else if let Some(caps) = glide_re.captures(input) {
            let path = caps[1].to_string();
            let to = caps[2].to_string();
            Command::Glide { path, to }
        } else if let Some(caps) = ok_re.captures(input) {
            let username = caps[1].to_string();
            Command::Ok(username)
        } else if let Some(caps) = no_re.captures(input) {
            let username = caps[1].to_string();
            Command::No(username)
        } else if let Some(caps) = help_re.captures(input) {
            let command = caps.get(1).map(|m| m.as_str().to_string());
            Command::Help(command)
        } else {
            Command::InvalidCommand(input.to_string())
        }
    }

    fn get_str(&self) -> Result<String, String> {
        Ok(match self {
            Command::List => "list".to_string(),
            Command::Requests => "reqs".to_string(),
            Command::Glide { path, to } => format!("glide {} @{}", path, to),
            Command::Ok(user) => format!("ok @{}", user),
            Command::No(user) => format!("no @{}", user),
            Command::Help(command) => {
                format!("help {}", command.as_ref().unwrap_or(&String::new()))
                    .trim()
                    .to_string()
            }
            Command::InvalidCommand(s) => return Err(s.to_string()),
        })
    }
}
```

I have also implemented a `get_str` method which converts a `Command` back to a `String`. It is not immediately useful to us, but I have gut feeling that it will come in handy. Now let's implement this logic in our `handle_commands` function. 
```rust title="glide-server/src/main.rs"
async fn handle_command(
    command: &str,
    _username: &str,
    socket: &mut TcpStream,
    state: &SharedState,
) -> Result<(), Box<dyn std::error::Error>> {
    let command = Command::parse(command);
    match command {
        Command::List => {
			// -- snip --
        }
        Command::Requests => todo!(),
        Command::Glide { path, to } => todo!(),
        Command::Ok(user) => todo!(),
        Command::No(user) => todo!(),
        Command::Help(cmd) => {
			// -- snip --
        }
        Command::InvalidCommand(cmd) => {
            let response = format!(
                "Unknown command: {}\nType 'help' for available commands.",
                cmd,
            );
            socket.write_all(response.as_bytes()).await?;
        }
    }

    Ok(())
}
```

And now, we are back on track! See [commit](https://github.com/ngpal/glide/commit/d2149f7a1775c3467e91e0b0e49ec880ca160f70) for more details
## Adding Commands
Let's get to adding the rest of the commands now!
### Command - `reqs`
So you may have noticed this `reqs` or `Requests` command. It wasn't mentioned in [[5. Major Overhauls and Commands#Commands|the commands description]], but the purpose of this command will be to see if we have any requests coming to us. But for that we need to keep track of all the requests right? So let's take a 
#### Detour - Modifying State to Handle Requests
Right now, our shared state looks something like
```rust title="glide-server/src/main.rs"
type SharedState = Arc<Mutex<HashMap<String, String>>>;
```

So let's modify the value of the hash map to be a custom `Request` struct which can handle both the socket and requests. But wait, should it be outgoing or incoming requests? With how small scale our project is, and our current CLI structure's limitations, we wont be having more than one request at a time from one user, so it doesn't matter. But this is purely a problem with our client application. What's the problem? Well, skill issue üò¨. Right now in the client, our inputs and outputs are blocking, meaning, when we're waiting for input we can't run anything in the background until the input is submitted, meaning, we can't notify the users of a new request (hence the `reqs` command), nor can we notify the sender that their request. So, for now, our client application is a bit lacking. 

We could receive many requests and have the receiver check with `reqs`, but there's no reliable way to notify the sender that their requests have been accepted or rejected. Unless we show both incoming and outgoing requests with `reqs`. Progress bars on the senders side is out of question though. I will cook up something with  the `crossterm` crate soon for a better client, but for now, this is what we have. 

So let's consider that yes there can be multiple requests, as the number of users increase, viewing and accepting requests become far easier if we store incoming requests instead, because look up time for a user is constant (because of the `HashMap`), and the receiver only has to check it's requests list instead of looking at every other user. 

```rust title="glide-server/src/main.rs 68:1"
struct Request {
    from_username: String,
    filename: String,
    size: u64,
}

struct UserData {
    socket: String,
    incoming_requests: Vec<Request>,
}

type SharedState = Arc<Mutex<HashMap<String, UserData>>>;
```

Here we have a `HashMap` which maps usernames to `UserData`. Now let's add a method to register a new user, and also modify `remove_client` to also remove all outgoing requests the user may have sent.
```rust glide-server/src/main.rs
async fn add_client(
    username: &str,
    socket: &mut TcpStream,
    state: &SharedState,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut clients = state.lock().await;
    clients.insert(
        username.to_string(),
        UserData {
            socket: socket.peer_addr()?.to_string(),
            incoming_requests: vec![],
        },
    );
    Ok(())
}

async fn remove_client(username: &str, state: &SharedState) {
    let mut clients = state.lock().await;

    // Remove the client
    clients.remove(username);

    // Collect requests to be removed
    let mut to_remove = Vec::new();
    for (user, client) in clients.iter() {
        for (i, req) in client.incoming_requests.iter().enumerate() {
            if req.from_username == username {
                to_remove.push((user.clone(), i));
            }
        }
    }

    // Remove the collected requests
    for (user, index) in to_remove {
        if let Some(client) = clients.get_mut(&user) {
            client.incoming_requests.remove(index);
        }
    }

    println!("Client @{} disconnected", username);
}
```

See [commit](https://github.com/ngpal/glide/commit/c421e1148667a3b3cae5f55f38db9d6954ed3486) for more details.
## Roadblock

Wait. What good is the `reqs` command without any way to give new requests to users?? üò¨. My bad, guys. So we will have to implement the `glide` command first. So let's get that done real quick
### Command - `glide path/to/file @username`
So the glide command takes 2 arguments, `path/to/file` and `@username`. So we need to validate
- If the file exists
- If the recipient exists

So what're we waiting for? 
